import logging
import os
import threading
from http.server import HTTPServer, BaseHTTPRequestHandler
from telegram import Update
from telegram.ext import (
    ApplicationBuilder, CommandHandler, MessageHandler,
    ContextTypes, filters
)

# â”€â”€â”€ ĞĞĞ¡Ğ¢Ğ ĞĞ™ĞšĞ˜ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
BOT_TOKEN  = os.environ["BOT_TOKEN"]
OWNER_ID   = int(os.environ["OWNER_ID"])
OWNER_TAG  = os.environ.get("OWNER_TAG", "@STTS84")
PORT       = int(os.environ.get("PORT", "8000"))
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

logging.basicConfig(level=logging.INFO)

pending_replies: dict[int, int] = {}   # msg_id â†’ user_id
known_users:     set[int]       = set()  # Ğ²ÑĞµ user_id ĞºÑ‚Ğ¾ Ğ¿Ğ¸ÑĞ°Ğ» Ğ±Ğ¾Ñ‚Ñƒ
banned_users:    set[int]       = set()  # Ğ·Ğ°Ğ±Ğ°Ğ½ĞµĞ½Ğ½Ñ‹Ğµ user_id


# â”€â”€ HTTP-ÑĞµÑ€Ğ²ĞµÑ€ Ğ´Ğ»Ñ Render â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class HealthHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        self.send_response(200)
        self.end_headers()
        self.wfile.write(b"Bot is running!")
    def log_message(self, *args): pass

def run_http():
    HTTPServer(("0.0.0.0", PORT), HealthHandler).serve_forever()


# â”€â”€ /start â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def start(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if user.id == OWNER_ID:
        await update.message.reply_text(
            "ğŸ‘‘ Ğ’Ñ‹ Ğ²Ğ»Ğ°Ğ´ĞµĞ»ĞµÑ† Ğ±Ğ¾Ñ‚Ğ°.\n\n"
            "ğŸ“‹ ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹:\n"
            "/ban <id> â€” Ğ·Ğ°Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ\n"
            "/unban <id> â€” Ñ€Ğ°Ğ·Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ\n"
            "/broadcast <Ñ‚ĞµĞºÑÑ‚> â€” Ñ€Ğ°ÑÑÑ‹Ğ»ĞºĞ° Ğ²ÑĞµĞ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑĞ¼\n"
            "/users â€” ÑĞ¿Ğ¸ÑĞ¾Ğº Ğ²ÑĞµÑ… Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹\n\n"
            "Ğ§Ñ‚Ğ¾Ğ±Ñ‹ Ğ¾Ñ‚Ğ²ĞµÑ‚Ğ¸Ñ‚ÑŒ â€” Ğ½Ğ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ Reply Ğ½Ğ° ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ."
        )
        return

    known_users.add(user.id)
    await update.message.reply_text(
        f"ğŸ‘‹ ĞŸÑ€Ğ¸Ğ²ĞµÑ‚!\n"
        f"Ğ­Ñ‚Ğ¾Ñ‚ Ğ±Ğ¾Ñ‚ Ğ¿Ğ¾Ğ·Ğ²Ğ¾Ğ»ÑĞµÑ‚ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑÑ‚ÑŒ {OWNER_TAG} Ğ°Ğ½Ğ¾Ğ½Ğ¸Ğ¼Ğ½Ñ‹Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ.\n\n"
        f"ğŸ’¬ ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞ¹Ñ‚Ğµ Ğ»ÑĞ±Ğ¾Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ: Ñ‚ĞµĞºÑÑ‚, Ñ„Ğ¾Ñ‚Ğ¾, Ğ²Ğ¸Ğ´ĞµĞ¾, Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚, Ğ°ÑƒĞ´Ğ¸Ğ¾, Ğ³Ğ¾Ğ»Ğ¾ÑĞ¾Ğ²Ğ¾Ğµ, ÑÑ‚Ğ¸ĞºĞµÑ€ Ğ¸Ğ»Ğ¸ GIF.\n"
        f"ğŸ“Œ Ğ’ÑĞµ Ğ²Ğ°ÑˆĞ¸ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ Ğ±ÑƒĞ´ÑƒÑ‚ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ»ĞµĞ½Ñ‹ Ğ°Ğ½Ğ¾Ğ½Ğ¸Ğ¼Ğ½Ğ¾: Ğ¾Ğ½ Ğ½Ğµ Ğ±ÑƒĞ´ĞµÑ‚ Ğ·Ğ½Ğ°Ñ‚ÑŒ, ĞºÑ‚Ğ¾ Ğ’Ñ‹."
    )


# â”€â”€ /ban â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def ban_cmd(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != OWNER_ID:
        return
    if not ctx.args:
        await update.message.reply_text("Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ: /ban <user_id>")
        return
    try:
        uid = int(ctx.args[0])
        banned_users.add(uid)
        await update.message.reply_text(f"ğŸš« ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ {uid} Ğ·Ğ°Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½.")
    except ValueError:
        await update.message.reply_text("âŒ ĞĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ ID.")


# â”€â”€ /unban â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def unban_cmd(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != OWNER_ID:
        return
    if not ctx.args:
        await update.message.reply_text("Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ: /unban <user_id>")
        return
    try:
        uid = int(ctx.args[0])
        banned_users.discard(uid)
        await update.message.reply_text(f"âœ… ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ {uid} Ñ€Ğ°Ğ·Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½.")
    except ValueError:
        await update.message.reply_text("âŒ ĞĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ ID.")


# â”€â”€ /users â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def users_cmd(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != OWNER_ID:
        return
    if not known_users:
        await update.message.reply_text("ĞŸĞ¾ĞºĞ° Ğ½Ğ¸ĞºÑ‚Ğ¾ Ğ½Ğµ Ğ¿Ğ¸ÑĞ°Ğ» Ğ±Ğ¾Ñ‚Ñƒ.")
        return
    lines = []
    for uid in known_users:
        status = "ğŸš«" if uid in banned_users else "âœ…"
        lines.append(f"{status} <code>{uid}</code>")
    await update.message.reply_text(
        f"ğŸ‘¥ ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ğ¸ ({len(known_users)}):\n" + "\n".join(lines),
        parse_mode="HTML"
    )


# â”€â”€ /broadcast â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def broadcast_cmd(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != OWNER_ID:
        return
    if not ctx.args:
        await update.message.reply_text("Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ: /broadcast <Ñ‚ĞµĞºÑÑ‚>")
        return

    text = " ".join(ctx.args)
    msg_text = f"ğŸ“¢ <b>Ğ¡Ğ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ¾Ñ‚ {OWNER_TAG}:</b>\n\n{text}"

    ok, fail = 0, 0
    for uid in known_users:
        if uid in banned_users:
            continue
        try:
            await ctx.bot.send_message(uid, msg_text, parse_mode="HTML")
            ok += 1
        except Exception:
            fail += 1

    await update.message.reply_text(
        f"ğŸ“Š Ğ Ğ°ÑÑÑ‹Ğ»ĞºĞ° Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ°:\nâœ… Ğ”Ğ¾ÑÑ‚Ğ°Ğ²Ğ»ĞµĞ½Ğ¾: {ok}\nâŒ ĞÑˆĞ¸Ğ±Ğ¾Ğº: {fail}"
    )


# â”€â”€ Ğ’Ñ…Ğ¾Ğ´ÑÑ‰Ğ¸Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ Ğ¾Ñ‚ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def handle_user_message(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    msg  = update.message

    if user.id == OWNER_ID:
        await handle_owner_reply(update, ctx)
        return

    # Ğ·Ğ°Ğ¿Ğ¾Ğ¼Ğ¸Ğ½Ğ°ĞµĞ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    known_users.add(user.id)

    # Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ±Ğ°Ğ½Ğ°
    if user.id in banned_users:
        await msg.reply_text("ğŸš« Ğ’Ñ‹ Ğ·Ğ°Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ñ‹ Ğ¸ Ğ½Ğµ Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑÑ‚ÑŒ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ.")
        return

    caption = f"ğŸ“¨ <b>ĞĞ¾Ğ²Ğ¾Ğµ Ğ°Ğ½Ğ¾Ğ½Ğ¸Ğ¼Ğ½Ğ¾Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ:</b>\n<i>ID: <code>{user.id}</code></i>"
    sent = None

    if msg.text:
        sent = await ctx.bot.send_message(OWNER_ID, f"{caption}\n\n{msg.text}", parse_mode="HTML")
    elif msg.photo:
        sent = await ctx.bot.send_photo(OWNER_ID, msg.photo[-1].file_id, caption=caption, parse_mode="HTML")
    elif msg.video:
        sent = await ctx.bot.send_video(OWNER_ID, msg.video.file_id, caption=caption, parse_mode="HTML")
    elif msg.document:
        sent = await ctx.bot.send_document(OWNER_ID, msg.document.file_id, caption=caption, parse_mode="HTML")
    elif msg.audio:
        sent = await ctx.bot.send_audio(OWNER_ID, msg.audio.file_id, caption=caption, parse_mode="HTML")
    elif msg.voice:
        sent = await ctx.bot.send_voice(OWNER_ID, msg.voice.file_id, caption=caption, parse_mode="HTML")
    elif msg.sticker:
        await ctx.bot.send_message(OWNER_ID, caption, parse_mode="HTML")
        sent = await ctx.bot.send_sticker(OWNER_ID, msg.sticker.file_id)
    elif msg.animation:
        sent = await ctx.bot.send_animation(OWNER_ID, msg.animation.file_id, caption=caption, parse_mode="HTML")
    elif msg.video_note:
        await ctx.bot.send_message(OWNER_ID, caption, parse_mode="HTML")
        sent = await ctx.bot.send_video_note(OWNER_ID, msg.video_note.file_id)
    else:
        await msg.reply_text("âš ï¸ Ğ­Ñ‚Ğ¾Ñ‚ Ñ‚Ğ¸Ğ¿ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ Ğ½Ğµ Ğ¿Ğ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ¸Ğ²Ğ°ĞµÑ‚ÑÑ.")
        return

    if sent:
        pending_replies[sent.message_id] = user.id

    await msg.reply_text("âœ… Ğ’Ğ°ÑˆĞµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾ Ğ°Ğ½Ğ¾Ğ½Ğ¸Ğ¼Ğ½Ğ¾!")


# â”€â”€ ĞÑ‚Ğ²ĞµÑ‚ Ğ²Ğ»Ğ°Ğ´ĞµĞ»ÑŒÑ†Ğ° â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def handle_owner_reply(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    msg = update.message

    if not msg.reply_to_message:
        return

    original_id = msg.reply_to_message.message_id
    target_user = pending_replies.get(original_id)

    if not target_user:
        await msg.reply_text("âŒ ĞĞµ Ğ¼Ğ¾Ğ³Ñƒ Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ°Ñ‚ĞµĞ»Ñ. ĞÑ‚Ğ²ĞµÑ‚ÑŒÑ‚Ğµ (Reply) Ğ½Ğ° ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ±Ğ¾Ñ‚Ğ°.")
        return

    prefix = "ğŸ“© <b>ĞĞ½Ğ¾Ğ½Ğ¸Ğ¼Ğ½Ñ‹Ğ¹ Ğ¾Ñ‚Ğ²ĞµÑ‚:</b>\n\n"

    try:
        if msg.text:
            await ctx.bot.send_message(target_user, prefix + msg.text, parse_mode="HTML")
        elif msg.photo:
            await ctx.bot.send_photo(target_user, msg.photo[-1].file_id, caption=prefix, parse_mode="HTML")
        elif msg.video:
            await ctx.bot.send_video(target_user, msg.video.file_id, caption=prefix, parse_mode="HTML")
        elif msg.document:
            await ctx.bot.send_document(target_user, msg.document.file_id, caption=prefix, parse_mode="HTML")
        elif msg.audio:
            await ctx.bot.send_audio(target_user, msg.audio.file_id, caption=prefix, parse_mode="HTML")
        elif msg.voice:
            await ctx.bot.send_voice(target_user, msg.voice.file_id, caption=prefix, parse_mode="HTML")
        elif msg.sticker:
            await ctx.bot.send_message(target_user, prefix, parse_mode="HTML")
            await ctx.bot.send_sticker(target_user, msg.sticker.file_id)
        elif msg.animation:
            await ctx.bot.send_animation(target_user, msg.animation.file_id, caption=prefix, parse_mode="HTML")
        else:
            await msg.reply_text("âš ï¸ Ğ­Ñ‚Ğ¾Ñ‚ Ñ‚Ğ¸Ğ¿ Ğ¾Ñ‚Ğ²ĞµÑ‚Ğ° Ğ½Ğµ Ğ¿Ğ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ¸Ğ²Ğ°ĞµÑ‚ÑÑ.")
            return

        await msg.reply_text("âœ… ĞÑ‚Ğ²ĞµÑ‚ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ»ĞµĞ½ Ğ°Ğ½Ğ¾Ğ½Ğ¸Ğ¼Ğ½Ğ¾.")
    except Exception as e:
        await msg.reply_text(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞµ: {e}")


# â”€â”€ Ğ—Ğ°Ğ¿ÑƒÑĞº â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def main():
    threading.Thread(target=run_http, daemon=True).start()
    print(f"HTTP-ÑĞµÑ€Ğ²ĞµÑ€ Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½ Ğ½Ğ° Ğ¿Ğ¾Ñ€Ñ‚Ñƒ {PORT}")

    app = ApplicationBuilder().token(BOT_TOKEN).build()
    app.add_handler(CommandHandler("start",     start))
    app.add_handler(CommandHandler("ban",       ban_cmd))
    app.add_handler(CommandHandler("unban",     unban_cmd))
    app.add_handler(CommandHandler("users",     users_cmd))
    app.add_handler(CommandHandler("broadcast", broadcast_cmd))
    app.add_handler(MessageHandler(filters.ALL & ~filters.COMMAND, handle_user_message))

    print("Ğ‘Ğ¾Ñ‚ Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½...")
    app.run_polling()


if __name__ == "__main__":
    main()
